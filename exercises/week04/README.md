# Week 4 Exercises: Data Structures & Algorithms

## üéØ M·ª•c ti√™u
- √Åp d·ª•ng arrays, vectors, strings v√†o game development
- Th·ª±c h√†nh linked lists v√† trees cho game state management
- S·ª≠ d·ª•ng hash tables v√† sets cho game data
- Hi·ªÉu v√† √°p d·ª•ng stacks, queues, priority queues
- Ph√¢n t√≠ch algorithm complexity cho game optimization

---

## üìã Danh s√°ch b√†i t·∫≠p

### **Exercise 4.1: Array & Vector Game Board**
**M√¥ t·∫£**: T·∫°o game board s·ª≠ d·ª•ng 2D array/vector v·ªõi c√°c operations c∆° b·∫£n.

**Y√™u c·∫ßu**:
```cpp
class GameBoard {
private:
    vector<vector<char>> board;
    int size;
    
public:
    GameBoard(int n = 3);
    void displayBoard();
    bool makeMove(int row, int col, char player);
    bool checkWin(char player);
    bool isFull();
    void reset();
    vector<pair<int,int>> getAvailableMoves();
};
```

**Test cases**:
- Kh·ªüi t·∫°o board 3x3, 5x5
- ƒê·∫∑t qu√¢n X, O v√†o c√°c v·ªã tr√≠ h·ª£p l·ªá/kh√¥ng h·ª£p l·ªá
- Ki·ªÉm tra th·∫Øng thua (ngang, d·ªçc, ch√©o)
- Reset board v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu

**Ti√™u ch√≠ ƒë√°nh gi√°**:
- ‚úÖ Code compile v√† ch·∫°y kh√¥ng l·ªói
- ‚úÖ T·∫•t c·∫£ test cases pass
- ‚úÖ Handle edge cases (out of bounds, occupied cells)
- ‚úÖ Efficient memory usage
- ‚úÖ Clean, readable code

---

### **Exercise 4.2: String Processing for Game Data**
**M√¥ t·∫£**: X√¢y d·ª±ng h·ªá th·ªëng x·ª≠ l√Ω string cho game save/load.

**Y√™u c·∫ßu**:
```cpp
class GameDataProcessor {
public:
    string serializeBoard(const vector<vector<char>>& board);
    vector<vector<char>> deserializeBoard(const string& data);
    bool validatePlayerName(const string& name);
    string formatScore(const map<string, int>& scores);
    vector<string> parseCommands(const string& input);
};
```

**Test cases**:
- Serialize/deserialize board states
- Validate player names (length, characters)
- Format leaderboard display
- Parse user commands ("move 1 2", "save game1", "load game2")

**Bonus**:
- Implement string compression for large boards
- Add error handling for corrupted save data

---

### **Exercise 4.3: Linked List Move History**
**M√¥ t·∫£**: S·ª≠ d·ª•ng linked list ƒë·ªÉ l∆∞u tr·ªØ l·ªãch s·ª≠ n∆∞·ªõc ƒëi.

**Y√™u c·∫ßu**:
```cpp
struct Move {
    int row, col;
    char player;
    time_t timestamp;
    Move* next;
    
    Move(int r, int c, char p) : row(r), col(c), player(p), 
                                timestamp(time(nullptr)), next(nullptr) {}
};

class MoveHistory {
private:
    Move* head;
    Move* tail;
    int count;
    
public:
    void addMove(int row, int col, char player);
    void undoLastMove();
    void displayHistory();
    Move* getLastMove();
    int getMoveCount();
    ~MoveHistory(); // Proper cleanup
};
```

**Test cases**:
- Add 10 moves, verify count and order
- Undo last 3 moves, check remaining moves
- Display history in chronological order
- Memory leak check (no memory leaks after destruction)

---

### **Exercise 4.4: Binary Tree Game State Storage**
**M√¥ t·∫£**: S·ª≠ d·ª•ng binary tree ƒë·ªÉ l∆∞u tr·ªØ v√† t√¨m ki·∫øm game states.

**Y√™u c·∫ßu**:
```cpp
struct GameState {
    vector<vector<char>> board;
    char currentPlayer;
    int moveCount;
    string stateID; // Hash of the board
    
    GameState* left;
    GameState* right;
};

class GameStateTree {
private:
    GameState* root;
    
public:
    void insertState(const vector<vector<char>>& board, char player);
    GameState* findState(const string& stateID);
    void inorderTraversal(); // Display all states
    int getTreeHeight();
    int getNodeCount();
};
```

**Test cases**:
- Insert 20 different game states
- Search for existing and non-existing states
- Verify BST property (states ordered by stateID)
- Calculate tree height and node count

---

### **Exercise 4.5: Hash Table Player Statistics**
**M√¥ t·∫£**: S·ª≠ d·ª•ng hash table (unordered_map) ƒë·ªÉ tracking player stats.

**Y√™u c·∫ßu**:
```cpp
struct PlayerStats {
    string name;
    int wins;
    int losses;
    int draws;
    double winRate;
    vector<time_t> gameHistory;
    
    void updateStats(char result); // 'W', 'L', 'D'
    void calculateWinRate();
};

class PlayerDatabase {
private:
    unordered_map<string, PlayerStats> players;
    
public:
    void addPlayer(const string& name);
    void updatePlayerResult(const string& name, char result);
    PlayerStats getPlayerStats(const string& name);
    vector<pair<string, double>> getLeaderboard();
    void displayTopPlayers(int count = 10);
    bool playerExists(const string& name);
};
```

**Test cases**:
- Add 100 players v·ªõi random results
- Update stats v√† verify calculations
- Get leaderboard sorted by win rate
- Handle non-existent players gracefully

---

### **Exercise 4.6: Stack-based Undo System**
**M√¥ t·∫£**: Implement undo/redo system s·ª≠ d·ª•ng stacks.

**Y√™u c·∫ßu**:
```cpp
struct GameSnapshot {
    vector<vector<char>> boardState;
    char currentPlayer;
    int moveNumber;
};

class UndoRedoSystem {
private:
    stack<GameSnapshot> undoStack;
    stack<GameSnapshot> redoStack;
    int maxUndoLevels;
    
public:
    UndoRedoSystem(int maxLevels = 50);
    void saveState(const vector<vector<char>>& board, char player, int move);
    GameSnapshot undo();
    GameSnapshot redo();
    bool canUndo();
    bool canRedo();
    void clearHistory();
};
```

**Test cases**:
- Save 10 states, undo 5, redo 3
- Verify stack limits (max 50 undo levels)
- Clear history and verify empty stacks
- Handle undo/redo when stacks are empty

---

### **Exercise 4.7: Priority Queue AI Move Scoring**
**M√¥ t·∫£**: S·ª≠ d·ª•ng priority queue ƒë·ªÉ sort AI moves theo score.

**Y√™u c·∫ßu**:
```cpp
struct AIMove {
    int row, col;
    int score;
    string strategy; // "win", "block", "center", "corner"
    
    // For priority queue (higher score = higher priority)
    bool operator<(const AIMove& other) const {
        return score < other.score;
    }
};

class AIMoveEvaluator {
private:
    priority_queue<AIMove> moveQueue;
    
public:
    void evaluateAllMoves(const vector<vector<char>>& board, char aiPlayer);
    AIMove getBestMove();
    vector<AIMove> getTopNMoves(int n);
    void clearQueue();
    int getQueueSize();
    
private:
    int calculateMoveScore(int row, int col, const vector<vector<char>>& board, char player);
    string determineMoveStrategy(int row, int col, const vector<vector<char>>& board);
};
```

**Test cases**:
- Evaluate moves tr√™n board c√≥ winning opportunities
- Verify highest scored moves ƒë∆∞·ª£c return ƒë·∫ßu ti√™n
- Test v·ªõi empty board (t·∫•t c·∫£ moves score b·∫±ng nhau)
- Performance test v·ªõi large boards (5x5, 7x7)

---

### **Exercise 4.8: Algorithm Complexity Analysis**
**M√¥ t·∫£**: Implement v√† benchmark c√°c algorithms v·ªõi different complexities.

**Y√™u c·∫ßu**:
```cpp
class AlgorithmBenchmark {
public:
    // O(n¬≤) - Brute force win checking
    bool checkWinBruteForce(const vector<vector<char>>& board, char player);
    
    // O(1) - Optimized win checking (ch·ªâ check around last move)
    bool checkWinOptimized(const vector<vector<char>>& board, char player, int lastRow, int lastCol);
    
    // O(n log n) - Sort moves by some criteria
    vector<pair<int,int>> sortMovesByDistance(const vector<pair<int,int>>& moves, int centerRow, int centerCol);
    
    // O(n) - Linear search for best move
    pair<int,int> findBestMoveLinear(const vector<vector<int>>& scoreBoard);
    
    // Benchmark functions
    double measureExecutionTime(function<void()> func);
    void compareAlgorithmPerformance();
};
```

**Test cases**:
- Benchmark v·ªõi board sizes: 3x3, 5x5, 10x10, 20x20
- Compare execution times c·ªßa brute force vs optimized
- Verify t·∫•t c·∫£ algorithms produce correct results
- Create performance report

**Expected Results**:
- O(1) algorithm should be fastest
- O(n¬≤) algorithm should scale poorly v·ªõi large boards
- Performance differences should be measurable and documented

---

## üß™ Mini Project: Complete Data Structure Integration

### **Project 4.9: Tic-Tac-Toe v·ªõi Advanced Data Structures**
**M√¥ t·∫£**: T√≠ch h·ª£p t·∫•t c·∫£ data structures ƒë√£ h·ªçc v√†o m·ªôt complete tic-tac-toe system.

**Architecture**:
```cpp
class AdvancedTicTacToe {
private:
    // Core game
    GameBoard board;                    // Exercise 4.1
    GameDataProcessor dataProcessor;    // Exercise 4.2
    
    // History and states
    MoveHistory moveHistory;            // Exercise 4.3
    GameStateTree stateTree;           // Exercise 4.4
    UndoRedoSystem undoSystem;         // Exercise 4.6
    
    // Player management
    PlayerDatabase playerDB;            // Exercise 4.5
    
    // AI system
    AIMoveEvaluator aiEvaluator;       // Exercise 4.7
    
    // Performance monitoring
    AlgorithmBenchmark benchmark;       // Exercise 4.8
    
public:
    void playGame();
    void showMainMenu();
    void handlePlayerInput();
    void saveGameState();
    void loadGameState();
    void showStatistics();
    void runPerformanceTests();
};
```

**Features**:
1. **Complete game flow** v·ªõi 2-player mode
2. **Save/Load system** v·ªõi serialization
3. **Player statistics** tracking v√† leaderboard
4. **Undo/Redo** functionality
5. **Basic AI** v·ªõi move scoring
6. **Performance monitoring** v√† benchmarking
7. **Full history tracking** c·ªßa t·∫•t c·∫£ moves

**Test Requirements**:
- Ch∆°i complete game t·ª´ start ƒë·∫øn finish
- Test save/load functionality
- Verify player stats accuracy
- Test undo/redo system
- Performance benchmark report
- Memory usage analysis

**Bonus Features**:
- Multiple board sizes (3x3, 5x5)
- Different AI difficulty levels
- Game replay functionality
- Export statistics to file
- Multi-language support

---

## üìä Grading Criteria

### **Individual Exercises (70%)**
- **Correctness (40%)**: Code ch·∫°y ƒë√∫ng v√† pass t·∫•t c·∫£ test cases
- **Code Quality (20%)**: Clean, readable, well-documented code
- **Efficiency (10%)**: Proper algorithm complexity v√† memory usage

### **Mini Project (30%)**
- **Integration (15%)**: T·∫•t c·∫£ components work together
- **Features (10%)**: All required features implemented
- **Testing (5%)**: Comprehensive testing v√† error handling

### **Bonus Points (up to +20%)**
- Creative additional features
- Performance optimizations
- Excellent documentation
- Advanced error handling

---

## üöÄ Getting Started

1. **Setup Development Environment**:
   ```bash
   # Create week04 workspace
   mkdir week04_workspace
   cd week04_workspace
   
   # Setup basic project structure
   mkdir src include tests
   ```

2. **Recommended Development Order**:
   - Start v·ªõi Exercise 4.1 (GameBoard)
   - Build incrementally: 4.2 ‚Üí 4.3 ‚Üí 4.4 ‚Üí 4.5
   - Implement performance exercises: 4.6 ‚Üí 4.7 ‚Üí 4.8
   - Integrate everything trong Mini Project 4.9

3. **Testing Strategy**:
   - Write unit tests cho m·ªói class/function
   - Use assertions ƒë·ªÉ verify correctness
   - Create sample data cho testing
   - Benchmark performance regularly

4. **Resources**:
   - STL documentation: [cppreference.com](https://cppreference.com)
   - Algorithm complexity reference: [Big O Cheat Sheet](https://www.bigocheatsheet.com)
   - Data structures visualizations: [visualgo.net](https://visualgo.net)

---

## üìù Submission Guidelines

### **Code Organization**:
```
week04_submission/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ exercise_4_1.cpp
‚îÇ   ‚îú‚îÄ‚îÄ exercise_4_2.cpp
‚îÇ   ‚îú‚îÄ‚îÄ ...
‚îÇ   ‚îî‚îÄ‚îÄ mini_project.cpp
‚îú‚îÄ‚îÄ include/
‚îÇ   ‚îú‚îÄ‚îÄ game_board.h
‚îÇ   ‚îú‚îÄ‚îÄ data_processor.h
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ test_exercise_4_1.cpp
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ docs/
‚îÇ   ‚îú‚îÄ‚îÄ performance_report.md
‚îÇ   ‚îî‚îÄ‚îÄ design_decisions.md
‚îî‚îÄ‚îÄ README.md
```

### **Documentation Requirements**:
- Comments trong code explaining complex logic
- README.md v·ªõi build instructions
- Performance report v·ªõi benchmark results
- Design decisions documentation

### **Deadline**: End of Week 4
### **Submission Method**: Git commit v·ªõi tag "week04-submission"

---

**üéØ Learning Outcomes**: Sau Week 4, b·∫°n s·∫Ω th√†nh th·∫°o fundamental data structures v√† c√≥ th·ªÉ apply ch√∫ng hi·ªáu qu·∫£ trong game development v√† software engineering n√≥i chung.
